# 최지율

## 🔄️ 동기화

### 🍇 임계 영역이란? (Critical Section)

임계영역이란 **공유 변수 영역**으로 볼 수 있는데 병렬 컴퓨팅에서 **둘 이상의 스레드가 동시에 접근해서는 안되는 자원을 접근하는 코드의 일부**를 말합니다.

<figure><img src="../../../.gitbook/assets/image (82).png" alt=""><figcaption></figcaption></figure>

### 🍈 임계 영역에 들어가는 것을 막는 방법은?

임계 영역에 들어가는 것을 정하기 위한 방법으로는 **뮤텍스, 세마포어, 모니터** 등의 해결 방법 등이 있습니다.

<figure><img src="../../../.gitbook/assets/image (83).png" alt=""><figcaption></figcaption></figure>

* 밑에서 설명 드릴 뮤텍스, 세마포어, 모니터 등을 활용한 일종의 LOCK을 걸어 해당 변수에 대한 접근을 막고 순차적으로 실행 할 수 있도록 합니다.

### &#x20;🍉 경쟁상태 란? (Race Condition)

<figure><img src="../../../.gitbook/assets/image (84).png" alt=""><figcaption></figcaption></figure>

* **둘 이상**의 입력 또는 **조작의 타이밍이나 순서** 등이 **결과 값에 영향을 줄 수 있는 상태**를 말합니다.
* 즉, 하나의 자원에 여러 개의 프로세스가 동시에 접근을 시도할 때 자료의 일관성을 해치는 결과가 나타날 수 있습니다.

### &#x20;🍊 기아상태 란? (Starvation)

**특정 프로세스**의 우선 순위가 낮아 **원하는 자원을 계속하여 할당 받지 못하는 상태**를 의미합니다.

<figure><img src="../../../.gitbook/assets/image (85).png" alt="" width="450"><figcaption><p><strong>http://www.aleclongstreth.com/</strong></p></figcaption></figure>

* 예를 들면, 위 사진과 같이 우선순위가 낮은 프로세스들이 대기하고 있어도 높은 우선순위의 프로세스가 끼어들 경우 낮은 우선순위의 프로세스들은 계속 대기 해야합니다.
* **기아상태 해결방법**
  1. 오래 기다린 프로세스의 우선순위 높이는 방법이 있습니다.
  2. 상황에 따라 우선순위가 아닌 요청 순서대로 처리하는 요청큐 사용하는 방법이 있습니다.

### 🍋 교착상태 란? (Deadlock)

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption><p>서로 기다리며 아무일도 진행하지 못하는 상황</p></figcaption></figure>

* 교착 상태란 두 개 이상의 작업이 서로의 작업이 끝나기 만을 기다리며 서로 아무런 행동을 취하지 못하는 상황을 이야기 합니다.
* 아직까진 이 문제를 해결하는 일반적인 확실한 정해진 방법은 없는 상태입니다.
  * 대신 아래 설명에 여러가지 해결 방안은 존재합니다.

#### ⚖️ 교착상태 발생 조건

1971년 E. G. 코프만 교수가 정의하였던 교착 상태가 발생하기 위한 **4가지 필요 조건**이 있습니다.

* 🔒 **상호배제 (Mutual Exclusion)**
  * 매 순간 하나의 프로세스만이 자원을 사용할 수 있습니다.
* **⏯️ 점유대기 (Hold and Wait)**
  * 프로세스가 다른 자원을 기다리며 자신이 보유한 자원을 내놓지 않고 계속 가지고 있습니다.
* **🛤️ 비선점 (No Preemption)**
  * 자원을 본인 프로세스만 스스로 반환할 수 있어,  다른 프로세스가 강제로 빼앗지 못하는 상태를 말합니다.
* **🔀 순환대기 (Circular Wait)**
  * 자원을 기다리는 프로세스간에 사이클이 형성되어 있습니다.
  * ex) 프로세스 P₁, P₂, P₃가 있을 경우
    1. P₁ -> P₂ 자원을 기다림.
    2. P₂ -> P₃ 자원을 기다림.
    3. P₃ -> P₁ 자원을 기다림.

### 🍍 교착상태 해결 방안

**데드락** **방지 / 회피 / 감지 및 복구 / 무시** 의 4가지 방법들을 소개해 드리겠습니다.

#### **🛡️ **<mark style="background-color:orange;">**데드락 방지 (Deadlock Prevention)**</mark>

* 자원 할당 시 Deadlock 발생 조건의 **4가지 중 하나라도 만족하지 못하도록 방지**하는 방법입니다.
  1. **Mutual Exclusion 방지**
     * 공유해서는 안되는 자원의 경우 반드시 동시에접근이 불가능 하도록 해야 합니다.
  2. **Hold and Wait 방지**
     * 프로세스 시작 시부터 종료 시까지 필요한 모든 자원을 할당 받고 시작하여 다른 자원을 요청할 필요가 없도록 하는 방법입니다. (자원 이용도 측면에선 비 효율적)
     * 새로운 자원이 필요할 경우 현재 보유하고 있던 모든 자원을 반납하고, 요청 하는 방법을 사용합니다. (반납한 순간 다른 프로세스가 점유하여 기아 현상 발생 가능성)
  3. **No Preemption 방지**
     * 프로세스가 어떤 자원이 필요할 때 이미 해당 자원이 다른 프로세스에 의해 이미 선점 되어 있을 경우, 모든 필요한 자원을 얻을 수 있을 때 프로세스를 다시 시작합니다.
     * 위와 같은 작업을 쉽게 하기 위해 자원을 쉽게 빼앗고 빼앗길 수 있도록 합니다.
       * 예를 들어 CPU의 컨텍스트 스위칭에서 PCB와 같이 자원을 빼앗더라도 쉽게 상태를 저장하고 복원 할 수 있도록 해야 합니다.
  4. **Circular Wait 방지**
     * 자원의 할당 순서를 정하여 정해진 순서대로만 자원을 할당 받게 합니다.

#### **🪖 **<mark style="background-color:orange;">**데드락 회피 (Deadlock Avoidance)**</mark>

자원 요청 시 받는 **부가적인 정보**를 이용해서 **데드락의 가능성이 없는 경우에만 자원을 할당**하는 방법입니다.

* **Safe state 해야합니다.**
  * 시스템 내의 프로세스들에 대한 **safe sequence**가 존재하는 상태이어야 합니다.
    * safe sequence란 쉽게 설명해서 현재 자원이 부족하여 실행 하지 못하는 프로세스가 있더라도 다른 프로세스부터 끝내고 돌려받은 자원으로 현재 프로세스를 만족 할 수 있다는 상태가 될 수 있는 것 입니다.
  * 해당 상태가 만족 되지 못하면 unsafe state한 상태이므로 Deadlock이 발생 할 가능성이 존재합니다.
* **회피 알고리즘**
  * **자원 할당 그래프 알고리즘** **(Resource Allocation Graph Algorithm)**
    * **단일** 인스턴스 경우에 사용됩니다.&#x20;
    * 자원을 할당 요청 시 할당해주더라도 사이클이 생성되지 않는 경우에만 요청 자원을 할당 하여 줍니다.
    * Cycle 생성여부 조사 시에는 프로세스 수가 n일 때 O(n²) 만큼 걸립니다.
  * **뱅커스 알고리즘 (Banker's Algorithm)**
    * **다중** 인스턴스 경우에 사용됩니다.&#x20;
    * 어느 프로세스가 최대로 사용할 자원 수가 현재 남아있는 자원보다 많을 경우 남아있는 자원이 더 많아질 때까지는 전혀 할당하여 주지 않습니다.
    * 예를 들어 현재 사용 가능한 자원이 10이 있을 때,
      * 한 프로세스가 최대 사용자원은 12이고 현재 당장 사용해야 하는 자원은 6일 경우에도 할당하여 주지 않습니다.
      * 한 프로세스가 최대 사용자원은 10이고 현재 사용해야 하는 자원도 10일 경우에는 할당하여 줍니다.
    * 위와 같이 현재 **당장 자원이 남아있더라도** 혹시 몰라서 **할당하여 주지 않으므로 비효율적**입니다.

#### **🚑 **<mark style="background-color:orange;">**데드락 감지 및 복구 (Deadlock Detection and Recovery)**</mark>

**데드락 발생은 허용**하되 발생하면 **감지해서 복구**를 하는 방법입니다.

* **데드락 찾는 방법**
  1. **단일** 인스턴스인 경우
     * Corresponding Wait-for Graph
       * 자원 할당 그래프에서 자원을 빼고 프로세스들 끼리만 연결하는 변형 그래프입니다.
       * 자원 할당 그래프와 동일하게 프로세스 수가 n일때 O(n²) 만큼 걸립니다.
  2. **다중** 인스턴스 인 경우
     * 뱅커스 알고리즘 (Banker's Algorithm)과 유사한 방법을 활용하여 찾습니다.
* **데드락 복구 방법**
  1. Process termination
     * 데드락에 연관된 모든 프로세스를 중단하는 방법입니다.
  2. Resource Preemption
     * 해결 될 때까지 데드락에 연관된 프로세스를 하나씩 중단 시키는 방법입니다.
     * 비용을 최소화 할 victim(종료될 프로세스)를 선정합니다.
       * 비용 계산 시 높은 비용의 프로세스들만 계속 종료 시킬 경우 기아 현상이 발생할 수 있으므로, 종료의 타겟이 된 횟수 같은 것 도 계산에 넣는 것을 고려해야 합니다.

#### **🔕 **<mark style="background-color:orange;">**데드락 무시 (Deadlock Ignorance)**</mark>

**데드락이 생기지 않는 다고 생각**하고 시스템이 책임을 지지 않는 것입니다.

* Deadlock은 매우 드물게 발생하므로 조치 하는 것 자체가 더 큰 Overhead 비용 일 수도 있습니다.
* 만약 시스템에 deadlock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사용자에게 직접 느끼게 하여 해결하도록 합니다.
* **UNIX, Windows 등 대부분의 범용적인 OS들이 채택하고 있는 방법**입니다.

### 🥭 세마포어란? (Semaphore)

다양한 스레드 간에 공유되는 **정수**(음수가 아닌) **변수**입니다.

* 세마포어는 **신호 메커니즘에 따라 작동**됩니다.
  * **wait** (**P**): 같이 들어 갈 수 없는 임계 영역에 들어가고자 하는 프로세스는 P연산을 거처야지만 들어 갈 수 있습니다.
  * **signal** (**V**): P연산을 통과해 임계 영역에 연산을 끝낸 프로세스가 V연산을 수행하여 다음 프로세스가 들어 갈 수 있게 합니다.
* **장점**
  * 한번에 **하나의 프로세스**만 임계 섹션에 액세스 하지만 **여러 스레드**가 허용됩니다.
    * 이는 즉, 한 프로세스의 여러 스레드가 동시에 중요한 섹션에 들어 갈 수 있으므로
    * 병렬 처리를 가능하게 하여 성능의 향상을 노릴 수 있습니다.
  * 기계에 독립적이므로 다양한 환경이나 플랫폼에서 사용 가능 합니다.
* **단점**
  * 우선순위의 역전이 발생합니다.&#x20;
    * ([동작하다 보면 가끔 높은 우선순위가 낮은 우선순위에게 밀림 (링크 맨 아래 참조)](https://beatmejy.tistory.com/22))
  * 프로그래밍 오류가 발생하기 쉬우며 올바른 방식으로 구현해야 합니다.
  * 운영체제는 wait과 signal 작업에 대한 모든 호출에 대해 감시하고 기록해야 합니다.&#x20;
    * 데드락 등의 문제를 감지하고 해결하기 위해 어떻게 실행되는지 기록 (이는 곧 오버헤드 발생)

### 🍎 뮤텍스란? (Mutex)

잠금 매커니즘을 제공하는 데 사용되는 **특정 종류의 이진 세마포어**라고 볼 수도 있습니다.

* 프로세스가 특정 시간에 코드의 **특정 섹션을** 실행하고 작업 할 수 있도록 코드의 특정 부분에 **상호 배제를 제공**하는데 주로 사용이 됩니다.
* **장점**
  1. 한 번에 하나의 프로세스만 임계 영역에 들어 갈 수 있으므로 간단한 잠금 매커니즘입니다.
  2. 데이터는 일관되게 유지되며 무결성을 유지할 수 있습니다.
* **단점**
  1. 임계 구역에 들어간 스레드가 휴먼 상태이면, 기아 상태로 이어질 수 있습니다.
  2. 우선순위가 높은 프로세스만 선점되면, 이 역시도 기아 상태로 이어질 수 있습니다.
  3. 이전 스레드가 스스로 임계 영역을 벗어나야지만 다른 프로세스가 임계 영역에 들어갈 수 있어서, 다른 프로세스가 잠금을 해제할 수 없습니다.
  4. [바쁜 대기](https://ko.wikipedia.org/wiki/%EB%B0%94%EC%81%9C\_%EB%8C%80%EA%B8%B0)가 발생하여 CPU 주기가 낭비 될 수 있습니다.

### 🍏 뮤텍스 VS 세마포어

<figure><img src="../../../.gitbook/assets/image (87).png" alt=""><figcaption><p><a href="https://beatmejy.tistory.com/22">내 블로그 중 일부이다.</a></p></figcaption></figure>



### 🍐 모니터란? (Monitor)

<figure><img src="../../../.gitbook/assets/image (88).png" alt=""><figcaption><p><a href="https://core.ewha.ac.kr/publicview/C0101020140411143154161543?vmode=f">반효경 교수님 OS 강의 중</a></p></figcaption></figure>

프로세스의 동기화를 제공하고 데드락을 방지하기 위한 프로그래밍 기법 중 하나 입니다.

* **모니터 내에서는 한번에 하나의 프로세스만이 활동**이 가능합니다.
* 실행되지 못한 **다른 프로세스**들은 모니터 밖의 **Entry Queue에서 대기**하고 있습니다.
* **Condition variable** (조건 변수)
  * 프로세스 모니터 안에서 실행 중이던 프로세스(스레드)가 특정 조건이 충족되어야 해서 대기해야 하는 경우 조건 변수를 사용하여 특정 조건이 충족되기를 기다릴 수 있게 저장 합니다.
  * 예를 들어 **x를 조건변수** 라고 한다면,
    * **wait**():
      * x.wait()을 호출한 프로세스는 다른 프로세스가 x.signal()를 호출 할 때까지 중단되어 있습니다.
    * **signal**()
      * x.signal()를 호출하게 되면 condition variable의 x 중 정확하게 하나의 중단된 프로세스를 다시 시작합니다.
      * wait() 등을 통해 중단된 프로세스가 없으면 아무 일도 일어나지 않습니다.
