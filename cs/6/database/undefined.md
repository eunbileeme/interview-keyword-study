# 최지율

## 🥜 Join

### SQL에서 Join이란 무엇이며 Join의 종류는 어떤 것들이 있을까요?

두 개 이상의 테이블에서 서로 묶어 원하는 데이터를 조회 하는 방법입니다.

<figure><img src="../../../.gitbook/assets/image (41).png" alt=""><figcaption><p><a href="https://hongong.hanbit.co.kr/sql-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-joininner-outer-cross-self-join/">https://hongong.hanbit.co.kr/sql-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-joininner-outer-cross-self-join/</a></p></figcaption></figure>

<table><thead><tr><th width="201">JOIN</th><th width="349">내용 설명</th><th>특징</th></tr></thead><tbody><tr><td>LEFT OUTER JOIN</td><td>왼쪽 테이블에만 존재하는 값과 A와 B에 공통으로 존재하는 데이터를 가져옵니다.</td><td>((A ∩ B) ∪ (A - B))</td></tr><tr><td>RIGHT OUTER JOIN</td><td>오른쪽 테이블에만 존재하는 값과 A와 B에 공통으로 존재하는 데이터를 가져옵니다.</td><td>((A ∩ B) ∪ (B - A))</td></tr><tr><td>FULL OUTER JOIN</td><td>양쪽 테이블 모든 데이터를 가져옵니다.</td><td>(A ∪ B)</td></tr><tr><td>INNER JOIN</td><td>두 테이블 간에 교집합 연산한 내용입니다.</td><td>(A ∩ B)<br>일반적으로 JOIN이라고 부르면  INNER JOIN을 의미합니다.</td></tr><tr><td>CROSS JOIN</td><td>한쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인하는 기능입니다. 전체 행 개수는 두 테이블의 각 행의 개수를 곱한 수가 됩니다.</td><td><p>(A × B)</p><p>카티션 곱(CARTESIAN PRODUCT)이라고도 합니다</p></td></tr><tr><td>SELF JOIN</td><td>자신이 자신과 조인하여 1개의 테이블만을 사용합니다.</td><td>(A ∩ A)</td></tr></tbody></table>

### 크로스 조인이 왜 성능상 좋지 않을까요?

<figure><img src="../../../.gitbook/assets/image (42).png" alt=""><figcaption></figcaption></figure>

두 테이블의 행 수를 곱한 만큼의 결과를 생성하기 때문에 행의 수가 많은 경우 성능상의 문제가 발생 할 수 있습니다.&#x20;

### FetchJoin이 SQL 수준에서 어떻게 이루어 질까요?

* FetchJoin은 Eager Loading(즉시 로딩)으로 필요한 데이터를 한 쿼리에서 즉시 가져옵니다.&#x20;
* 실제 질의하는 대상 Entity와 Fetch join이 걸려있는 Entity를 포함해 모든 컬럼을 조회를 하여  N+1 문제를 방지하고 성능을 향상시킬 수 있습니다.
* 실제 SQL에서는 필요한 다른 엔티티를 Inner Join으로 Join을 합니다.

### ON과 WHERE의 차이를 설명해주세요.

#### ON은

* 주로 Join 키워드와 함께 사용되며
* 두  테이블 간에 연결 조건을 지정할 때 사용됩니다.

#### WHERE은&#x20;

* 일반적으로 데이터를 필터링 하기 위해 사용됩니다.
* 조인된 결과에 대한 추가적인 조건을 지정할 때 사용됩니다.

### ON과 WHERE 중 무엇이 먼저 실행이 될까요?

#### 일반적으로 SQL 쿼리의 실행 순서는 다음과 같습니다

1. **FROM 절**:&#x20;
   * 데이터를 가져올 테이블이나 뷰를 지정합니다.
2. **JOIN 절**:&#x20;
   * 여러 테이블을 조인하여 하나의 결과 집합을 생성합니다.
3. **ON 조건**:&#x20;
   * JOIN 절과 함께 사용되며, 테이블 간의 연결 조건을 정의합니다.
4. **WHERE 절**:&#x20;
   * 특정 조건을 충족하는 행을 선택합니다.&#x20;
   * 조인된 결과에 대한 조건을 지정할 수 있습니다.
5. **GROUP BY 절**:&#x20;
   * 설정된 컬럼별로 데이터를 그룹화 합니다.&#x20;
   * 집계 함수(COUNT, SUM 등)와 함께 사용되어 그룹 단위로 계산합니다.
6. **HAVING 절**:&#x20;
   * GROUP BY로 그룹화된 결과에 대한 조건을 지정합니다.&#x20;
   * WHERE와 비슷하지만, GROUP BY 이후에 사용됩니다.
7. **SELECT 절**:&#x20;
   * 쿼리에서 반환할 열을 지정합니다. 집계 함수를 사용하거나, 특정 열을 선택하거나, 계산된 열을 추가할 수 있습니다.
8. **ORDER BY 절**:&#x20;
   * 결과를 오름차순(ASC) 또는 내림차순(DESC)으로 정렬합니다.
9. **LIMIT 또는 OFFSET 절**:&#x20;
   * 결과 집합의 크기를 제한하거나 오프셋을 설정 할 수 있습니다.

**위와 같이 JOIN 절인 ON이 먼저 실행이 되고 WHERE 문이 실행이 됩니다.**

### 서브 쿼리란 무엇일까요?

* 하나의 쿼리에서 SQL 문 안에 또 다른 SQL 문이 있을 때 안에 포함된 SQL 문을 서브쿼리라고 합니다
* 보통 서브쿼리에서 반환하는 결과가 메인쿼리에서 보조 용도로 사용됩니다

#### **사용위치 별 서브쿼리**

* **SELECT 절**
  * 스칼라 서브쿼리라 불립니다.
* **FROM 절**
  * 인라인 뷰라 불립니다.
* **WHERE 절**
  * 흔히 가장 많이 사용되며 서브쿼리(단일행/다중행)라 불립니다.
    * 단일 행의 경우 하나의 행만 반환되어 비교연산자(=, <, <=, >=, <>)를 사용합니다.&#x20;
    * 여러 행을 반환하는 서브쿼리로 IN, ANY, ALL, EXISTS를 사용해 비교합니다.
* 그 외에 사용 가능 한 곳
  * &#x20;HAVING절&#x20;
  * &#x20;ORDER BY절&#x20;
  * &#x20;INSERT문의 VALUES 절
  * &#x20;UPDATE문의 SET 절

### 서브 쿼리는 성능 저하가 왜 발생할까요

* 서브쿼리는 메인 쿼리의 각 행에 대해 실행될 수 있어 이로 인해 동일한 서브쿼리가 여러 번 실행되어야 할 수 있습니다.
* 또한 서브쿼리를 사용하면 일반적으로 쿼리가 더 복잡해지므로, 실행 계획 최적화가 어려워질 수 있고,
* 서브쿼리는 실체적인 데이터를 저장하지 않기 때문에 메타정보가 없어 옵티마이저(SQL 실행 계획을 수립, 관리하는 시스템)가 쿼리를 해석하기 위해 필요한 정보를 서브쿼리에서 읽어낼 수 없습니다.

## 🗂️ 파일 시스템

### 파일시스템이 왜 데이터베이스에서 읽을 때 보다 느릴까요?

1. **접근 방식의 차이**
   * **데이터베이스:** 데이터베이스는 인덱싱과 같은 고급 데이터 구조를 사용하여 빠르게 데이터에 접근할 수 있습니다.
   * **파일 시스템:** 파일 시스템은 파일을 읽고 쓰는 데 특화되어 있습니다. 데이터를 찾기 위해 파일을 순차적으로 읽어야 할 수 있어 성능에 영향을 미칠 수 있습니다.
2. **캐싱**
   * **데이터베이스:** 데이터베이스는 자주 사용되는 데이터를 메모리에 캐시하여 빠른 응답을 제공합니다. 이는 반복적인 쿼리에 대한 성능을 향상시킬 수 있습니다.
   * **파일 시스템:** 일반적으로 파일 시스템은 캐싱을 제공하지만, 데이터베이스만큼 효율적이지 않을 수 있습니다.
3. **쿼리 계획 최적화**
   * **데이터베이스:** 데이터베이스는 쿼리를 실행하기 전에 여러 기술을 사용하며 최적의 실행 계획을 결정하는데, 이를 통해 불필요한 작업을 줄이고 성능을 향상시킬 수 있습니다.
   * **파일 시스템:** 파일 시스템에서는 데이터 저장 및 검색을 효율적으로 수행할 수 없습니다.
4. **데이터 구조**
   * **데이터베이스:** 데이터베이스는 특정 유형의 데이터에 최적화된 데이터 구조를 사용할 수 있습니다. 또한 데이터 압축을 통해 디스크 공간을 절약하면서도 읽기 속도를 향상시킬 수 있습니다.
   * **파일 시스템:** 파일 시스템은 다양한 유형의 데이터를 다루기 위해 일반적인 목적의 데이터 구조를 사용합니다.
5. **중복된 데이터**
   * **데이터베이스**: 데이터베이스는 동일한 데이터를 한 곳에만 저장하고, 다른 위치에서는 해당 데이터에 대한 참조하며 일관된 상태를 유지하기 위해 정규화와 같은 기술을 사용합니다.
   * **파일시스템**: 동일한 데이터가 여러 파일에 중복 저장될 수 있으며, 이는 데이터 일관성을 유지하기 어렵게 만들 수 있습니다. 또한 중복 데이터를 수정하려면 모든 중복된 위치에서 수동으로 수정해야 합니다.

#### 📚 참고자료

[https://www.guru99.com/ko/difference-between-file-system-and-dbms.html](https://www.guru99.com/ko/difference-between-file-system-and-dbms.html)

## 🛠️  DBMS

### DBMS의 분류

#### **계층형 DBMS**

<figure><img src="../../../.gitbook/assets/image (43).png" alt=""><figcaption></figcaption></figure>

* 1960대에 시작되어 각 계층은 tree 형태를 갖습니다.
* 계층형 DBMS의 문제는 처음 구성을 완료한 후에 이를 변경하기가 상당히 까다롭습니다.
* 다른 구성원을 찾아가는 것이 비효율 적입니다.
  * 예를 들어 회계팀에서 기술팀을 찾아가기 위해선 회계이사 -> 사장 -> 기술이사와 같이 각 단계를 거쳐야 합니다.
* 이러한 단점들 때문에 현대에는 잘 쓰이지 않고 있습니다.

#### 망형 DBMS

<figure><img src="../../../.gitbook/assets/image (44).png" alt=""><figcaption></figcaption></figure>

* 계층형 DBMS의 문제점을 개선하기 위해서 1970년대에 등장하였습니다.
* 하위의 있는 구성원끼리도 연결되는 유연한 구조를 가지고 있습니다.
* 예를 들면 회계팀에서 기술팀을 찾아가는것도 연결을 추가하면 가능합니다.
* 하지만 모든 프로그래머가 모든 구조를 이해해야만 프로그램 작성이 가능하다는 단점이 존재합니다.
* 때문에 망형DBMS도 현대에는 잘 쓰이지 않고 있습니다.

#### 관계형 DBMS

| ID  | 이름  | 직급  | 부서  |
| --- | --- | --- | --- |
| 1   | 이사장 | 사장  | 관리  |
| 2   | 정이사 | 이사  | 회계  |
| 3   | 김회계 | 매니저 | 회계  |
| 4   | 박재무 | 프로  | 재무  |
| ... | ... | ... | ... |

* 주로 RDBMS(Relational DBMS)라고 부릅니다.
* 여러분들이 주로 잘 아시는 MySQL, PostgreSQL 등이 여기에 포함됩니다.
* 테이블이라는 최소 단위로 구성이 되며 하나 이상의 열과 행으로 이루어져 있고,
* 모든 데이터 테이블에 저장됩니다.

🖼️[ 그림 첨부자료](https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/)

### 데이터 독립성이란?

* 데이터베이스의 구조와 데이터의 내용이 서로 영향을 미치지 않는 것을 의미합니다.
* 이는 데이터베이스의 유지보수와 확장성을 향상시키는 장점을 가집니다.

### 논리적 데이터 독립성이란?

* 논리적 데이터 독립성은 데이터베이스의 논리적 구조가 변경되어도 응용 프로그램이나 사용자의 요구에 영향을 주지 않는 것을 말합니다.&#x20;
* 예를 들어, 테이블의 속성이나 관계가 추가되거나 삭제되어도 기존의 쿼리나 트랜잭션은 그대로 유지될 수 있습니다.

### 물리적 데이터 독립성이란?

* 물리적 데이터 독립성은 데이터베이스의 물리적 구조가 변경되어도 논리적 구조나 데이터의 내용에 영향을 주지 않는 것을 말합니다.&#x20;
* 예를 들어, 파일의 저장 방식이나 인덱스의 구성이 바뀌어도 데이터베이스의 스키마나 데이터는 그대로 유지될 수 있습니다.

### MySQL(DB)에 insert문 쿼리 시 DB 동작 과정

1. **연결 및 사용자 스레드 할당:**
   * 클라이언트가 MySQL 서버에 연결을 시도하면, MySQL Connectors는 클라이언트의 요청에 대한 연결을 수락하고 사용자 스레드를 할당합니다.
2. **인증 :**
   * 사용자 스레드가 할당되면 클라이언트의 사용자 인증이 진행됩니다.&#x20;
   * 사용자가 올바른 권한을 가지고 있는지 확인합니다.
3. **쿼리 파싱 및 최적화:**
   * 인증이 완료되면 MySQL 엔진에 전달됩니다.
   * MySQL 엔진의 토큰 파서를 통해 쿼리를 파싱하며, SQL을 MySQL이 이해 가능한 최소 단위로 잘라내고 문법 유효성을 검증합니다.
4. **전처리**
   * 쿼리에 포함된 테이블명, 컬럼명 등이 존재하는지 확인하고 사용자가 테이블에 접근할 수 있는지 확인합니다.&#x20;
   * 데이터 형식에 대한 변환과 함께 서브쿼리와 조인과 같은 복잡한 쿼리도 처리됩니다.
5. **옵티마이저 최적화:**
   * 전처리된 쿼리는 옵티마이저에게 전달되어 최적의 실행 계획을 결정합니다.
6. **데이터 락 및 동시성 제어:**
   * 쿼리 실행에 필요한 테이블 또는 레코드에 대한 데이터 락이 설정되고, 동시성을 관리하기 위한 메커니즘이 사용됩니다.
7. **데이터베이스 엔진에서 쿼리 실행:**
   * 최적화된 실행 계획에 따라 MySQL 엔진이 쿼리를 실행하고, 결과를 생성합니다.
8. **커밋 또는 롤백:**
   * 트랜잭션이 사용 중인 경우, 쿼리 실행 후 변경 사항은 커밋 또는 롤백됩니다.
9. **결과 반환:**
   * 쿼리 실행이 완료되면 MySQL 엔진은 결과를 사용자 스레드로 반환합니다.
   * 사용자 스레드는 클라이언트에게 결과를 전송하고, 클라이언트는 이를 받아 처리합니다.
10. **디스크 반영**:
    * 백그라운드 스레드에서 커밋되었으나 디스크에 반영되지 않은 내용을 디스크에 접근하여 일괄 처리합니다.
    * 이때 트랜잭션이 커밋되었을 때 변경사항을 저장한 트랜잭션 로그(Transaction Log)를 사용하여 변경된 데이터를 백그라운드에서 비동기적으로 디스크에 기록합니다.
    * InnoDB 스토리지 엔진에서는 변경된 페이지들을 "더티 페이지"로 추적하고, 주기적으로 체크포인트를 수행하여 더티 페이지를 디스크에 기록합니다.&#x20;
    * 이로써 효율적인 디스크 I/O가 이루어집니다.
