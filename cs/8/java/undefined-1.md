# 고청천

## 자료구조

### Set과 List

Set은 순서가 없는(unique) 항목의 모음입니다. 즉, 동일한 항목이 중복될 수 없습니다. List는 순서가 있는 항목의 모음입니다. 항목은 리스트 내에서 위치에 따라 인덱스로 접근할 수 있습니다. 중복된 항목을 포함할 수 있습니다.

### ArrayList 란

Set은 순서를 보장하지 않습니다. 다만 LinkedHashSet을 이용하면 입력된 순서대로 데이터가 관리되며 TreeSet의 경우, 이진탐색트리 기반이라 값들을 오름차순으로 정렬해 관리합니다

### 서버에 세션 저장 시 HashMap vs Concurrent HashMap

동적 배열은 메모리 상에서 일렬로 관리되며, 주소 공간이 가득 차면 grow() 함수를 호출하여 주소 공간을 1.5배로 늘립니다. 이러한 특징으로 인해 동적 배열은 반복문을 사용하여 요소에 접근할 때 성능상의 이점을 얻을 수 있습니다.

메모리 상에 연속된 공간으로 요소들을 저장합니다. 따라서 인덱스를 사용하여 요소에 직접 접근할 수 있으며, 이는 반복문을 효율적으로 실행할 수 있는 기반을 제공합니다. 메모리 상에서 일렬로 관리되기 때문에 요소들은 인접한 주소에 저장되어 있어 CPU 캐시의 지역성(locality) 원리에 따라 데이터를 빠르게 읽어올 수 있습니다.

또한, 동적 배열은 주소 공간이 가득 차게 되면 grow() 함수를 호출하여 주소 공간을 늘립니다. 이를 통해 동적 배열은 필요에 따라 메모리를 동적으로 할당하므로 유연하게 크기를 조정할 수 있습니다.

## 기타

### 라이브러리와 프레임워크 차이

프레임워크는 스스로 제어 흐름의 주도권을 가지며 라이브러리는 개발자가 가지고 있습니다.

### String, StringBuffer, StringBuilder

String은 immutable(불변), StringBuffer는 mutable(변함) String 객체는 이러한 이유로 문자열 연산이 많은 경우, 그 성능이 좋지 않습니다. StringBuffer/StringBuilder는 String과 다르게 동작합니다. 문자열 연산 등으로 기존 객체의 공간이 부족하게 되는 경우,기존의 버퍼 크기를 늘리며 유연하게 동작합니다. StringBuffer는 각 메서드별로 Synchronized Keyword가 존재하여, 멀티스레드 환경에서도 동기화를 지원.- 반면, StringBuilder는 동기화를 보장하지 않음.

### 스트림 사용이유

스트림을 사용하게 되면 가독성이 높아지게 됩니다. 또한 병렬 처리 기능을 지원하여서 멀티코어 프로세서를 적극 활용할 수 있습니다 그리고 지연평가를 통해 요소들을 실제 필요한 시점에 처리할 수 있습니다. 이를 통해 대량의 데이터를 다룰 때 모든 요소를 한 번에 메모리에 로드하지 않고 필요한 부분만 퍼리할 수 있습니다

### final 이란?

final 필드는 초기값이 선언되면 불변합니다. 객체 변수에 final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없습니다. 하지만 객체 내부 변수는 변경 가능합니다



```java
class Company{
    String name = "회사명";

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class Final_ex {
    public static void main(String[] args) {
    	final Company company = new Company();
    	//company = new Company(); //객체를 한번 생성했다면 재생성 불가능
    	company.setName("ex회사"); //클래스의 필드는 변경가능
    }
}
```

final 클래스는 상속이 불가능합니다 그치만 필드는 변경가능합니다

final 메서드는 상속받은 클래스는 재정의 할 수 없습니다.

### AOP란?

관점 지향 프로그래밍을 이야기 합니다. 횡단 관심사를 모듈화할 수 있습니다. 트랜잭션과 관련된 코드를 모든 필요한 코드에 개별적으로 구현하는 대신, 한 곳에서 구현하고 다른 코드에서 재사용할 수 있도록 분리하는 방법이 있습니다. 이를 위해 트랜잭션의 시작, 커밋, 롤백과 같은 코드를 모듈화하여 재사용 가능한 함수나 클래스로 작성하는 것이 효율적입니다. 이렇게 구현된 트랜잭션 코드는 다른 코드에서 필요할 때 호출하여 사용할 수 있습니다. 이렇게 하면 코드의 중복을 줄이고 유지보수성을 향상시킬 수 있습니다.

## Generic

### Generic 이란?

제네릭(Generic)은 자바에서 컬렉션 클래스나 메서드의 매개변수, 반환 타입 등에 타입 매개변수를 사용하여 다양한 타입의 객체를 처리할 수 있도록 하는 기능입니다. 제네릭을 사용하면 코드의 재사용성과 유연성을 높일 수 있으며, 타입 안정성(Type Safety)을 보장할 수 있습니다.

### 와일드 카드 어떻게 사용해야 할까?

비한정와일드 카드(\<?>) 를 사용하게 되면 제한 없이 어떤 타입이든 다룰 수 있게 됩니다 이를 제한 하기 위해 \<? extends T>, \<? super T>를 이용하는 것이 좋습니다

: 와일드 카드의 상한 제한을 설정합니다. 즉, T 타입이거나 T의 하위 타입인 객체들만 해당 와일드 카드에 대입될 수 있습니다. 이는 읽기 작업에 사용될 수 있습니다. 예를 들어, List는 Number 타입 또는 Number의 하위 타입인 Integer, Double 등의 리스트를 받을 수 있습니다. : 와일드 카드의 하한 제한을 설정합니다. 즉, T 타입이거나 T의 상위 타입인 객체들만 해당 와일드 카드에 대입될 수 있습니다. 이는 쓰기 작업에 사용될 수 있습니다. 예를 들어, List는 Integer 타입이거나 Integer의 상위 타입인 Number, Object 등의 리스트를 받을 수 있습니다.

## 컴파일

## war, jar 차이점

.jar 확장자 파일에는 Class와 같은 Java 리소스와 속성 파일, 라이브러리 및 액세서리 파일이 포함되어 있습니다. 쉽게 JAVA 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축한 파일로 생각하시면 되겠네요. 실제로 JAR 파일은 플랫폼에 귀속되는 점만 제외하면 WIN ZIP파일과 동일한 구조입니다. .war 확장자 파일은 servlet / jsp 컨테이너에 배치 할 수 있는 웹 어플리케이션(Web Application) 압축 파일 포맷입니다. JSP, SERVLET, JAR, CLASS, XML, HTML, JAVASCRIPT 등 Servlet Context 관련 파일들로 패키징 되어있습니다. WAR는 웹 응용 프로그램를 위한 포맷이기 때문에 웹 관련 자원만 포함하고 있으며 이를 사용하면 웹 어플리케이션을 쉽게 배포하고 테스트 할 수 있습니다.

### Java 컴파일 과정

자버 컴파일러가 자바 소스파일(.java)를 컴파일합니다. 이때 생성되는 파일은 바이트 코드(.class) 파일이며 컴퓨터가 읽을 수는 없고 자바 가상 머신이 이해할 수있는 코드입니다. 해당 코드가 JVM 클래스로더에게 전달됩니다. 클래스 로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역에 올립니다 클래스 로더 세부 동작 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드합니다.

검증 : 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사합니다.

준비 : 클래스가 필요로 하는 메모리를 할당합니다. (필드, 메서드, 인터페이스 등등)

분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경합니다.

초기화 : 클래스 변수들을 적절한 값으로 초기화합니다. (static 필드)

Excution Engine은 Jvm 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와 실행합니다 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행합니다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가집니다.

JIT 컴파일러(Just-In-Time Compiler) : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식입니다. 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠릅니다.
