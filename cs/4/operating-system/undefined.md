# 최지율

## 🍒 fork() 란?

* 유닉스와 같은 운영체제에서 프로세스가 자기 자신을 복제하는 동작입니다.
* Kernel 내부에 구현되어 있는 System Call의 일종이며 프로세스를 만드는 주된 방식입니다.

### fork()를 수행하는 이유 (장점)

* **동시성 향상 및 병렬성 증가**
  * 부모 프로세스가 자식 프로세스를 생성하여 동일한 코드를 병렬적으로 실행하기 때문에 동시 처리 능력이 향상됩니다.
* **멀티테스킹 가능**
  * 부모와 자식 프로세스가 독립적으로 실행 되어 서로에게 영향을 끼치지 않고 안전하게 병렬적으로 작업이 가능합니다.
* **프로세스 생성 오버헤드 감소**
  * 거의 동일한 로직을 반복하여 수행해야 하는 경우 프로세스를 새로 생성하는 오버헤드가 더 발생 할 수 있어 복제하여 사용하는 것이 더 효과적입니다.
  * 또한 어떠한 프로세스가 다른 프로그램을 실행해야 하는 경우에도 처음부터 생성하는 것보단 복제하여 exec()를 사용하여 덮어씌우는 것이 더 오버헤드가 적습니다.
* **IPC를 통한 프로세스 간 통신**
  * fork()를 사용하여 만든 프로세스간에는 IPC(inter-Process Communication)를 통해 서로 통신 할 수 있습니다.

### fork() 자식 프로세스 변환 예시

* 자식 프로세스가 생성되면 우선 실행 중 바뀌지 않는 텍스트(text, 프로그램 코드)영역은 공유합니다.
* 그리고 나머지부모 프로세스의 Stack, Heap, Data 뿐 아니라 부모 프로세스의 PCB(Process Control Block)도 그대로 복사합니다.

<figure><img src="../../../.gitbook/assets/image (32).png" alt=""><figcaption><p><a href="https://wslog.dev/fork-exec">https://wslog.dev/fork-exec</a></p></figcaption></figure>



그러면 아래와 같이 부모 process1, 자식 process2가 생성됩니다.

<figure><img src="../../../.gitbook/assets/image (33).png" alt=""><figcaption></figcaption></figure>

이 때 부모 프로세스에서 Page C의 데이터가 변경되면&#x20;

<figure><img src="../../../.gitbook/assets/image (34).png" alt=""><figcaption></figcaption></figure>

COW로 인해 공유하고 있던 데이터의 수정이 발생하였으므로 page C를 복사하여 다른 물리주소에 올려 수정을 하고, 수정이 발생한 프로세스인 부모 프로세스의 주소 참조를 변경하게 됩니다.

### COW(Copy on Write)란?

* COW란 메모리 관리 기술 중 하나로 주로 프로세스 간 메모리 공유를 효율적으로 관리하기 위한 방법 중 하나 입니다.
* 예를 들어 fork()를 사용하면 부모프로세스와 자식 프로세스가 처음에는 동일합니다.&#x20;
  * 그러므로 굳이 메모리를 낭비하지 않기 위해 복제를 하지 않고, 메모리를 공유하며 진행하다가
  * 다른  한쪽 프로세스에서 데이터가 변경되어 공유하지 못할 상황이 왔을때에 복사를 하여 수정된 데이터와 원본데이터를 분리하는 방법입니다.

## 🥜 IPC란?

* 프로세스 간에 데이터를 주고 받을 수 있는 행위를 뜻합니다.
* 주로 멀티프로세스 환경에서나 서로 다른 프로그램 간에 데이터를 전송하거나 공유할 때 사용됩니다.
* 주로 메시지 큐, 공유메모리, 파이프, 소켓, 신호 등이 있습니다.

### IPC 중 공유메모리에서 한 번 공유된 이후에 커널의 도움이 필요한지?

* 커널의 도움은 한 번 공유메모리를 만들 때 이후에는 더이상 커널의 도움이 필요하지 않습니다.
* 왼쪽 그림은 커널의 도움을 받는 메시지 전달 방법이고
* 오른쪽 그림은 공유메모리를 통해 커널의 개입 없이 메모리를 공유하는 모습입니다.
*

    <figure><img src="../../../.gitbook/assets/image (31).png" alt=""><figcaption><p>공룡 책 이미지</p></figcaption></figure>

## 🗃️ PCB 란?

* Process Control Block 으로 운영체제가 프로세스의 정보를 저장하는 자료 구조입니다.
  1. 프로세스 식별자
  2. 프로세스 상태: 생성, 준비, 실행, 대기, 종료
  3. 프로그램 계수기 (PC: Program Counter): 해당 프로세스가 다음번에 실행 할 명령어의 주소를 가르킵니다.
  4. CPU 레지스터 및 일반 레지스터: 스택 포인터(SP), 누산기(A), 명령어 레지스터(IR) 등
  5. CPU 스케줄링 정보: 우선순위, 스케줄링 알고리즘, CPU 점유시간, 최종 실행시각 등
  6. 메모리 관리 정보: 해당 프로세스 주소 공간 등
  7. 프로세스 계정 정보: 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 프로세스 등
  8. 입출력 상태 정보: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등
* PCB는 프로세스가 생성되고 종료될 때 까지 해당 정보들이 유지되며,
* 프로세스 간 전환 시 현재 실행 중인 프로세스를 PCB에 저장하고,
* 다음에 실행 될 프로세스의 PCB를 읽어 CPU 레지스터 등을 복원하는 등
* 멀티프로세스 환경에서 효율적으로 프로세스를 관리 할 수 있습니다.

### PCB는 어디에 저장되고 있을까요?

* PCB는 프로세스의 중요한 정보를 포함하고 있기 때문에 주로 운영체제의 커널 스택에 저장되고 있습니다.
  * 커널 스택에는 인터럽트 처리, 시스템 호출, 예외 처리 같은 운영체제 핵심 부분에서 실행되는 코드의 호출 스택 정보가 저장됩니다. 이는 각 프로세스나 스레드마다 별도의 커널 스택이 할당되어 격리 되어 있습니다.
  * 일부 OS는 편리성과 효율성을 위해 PCB를 커널 스택의 처음에 위치 시켜 PCB 주소에 빠르게 접근 할 수 있도록 합니다.

## 프로세스 동기화 하는 방법

* **뮤텍스**
  * 공유 자원에 대한 접근을 조절하기 위한 가장 기본적인 방법입니다.
  * 잠금과 해제 연산을 제공하여 한 번에 하나의 프로세스 또는 스레드 만이 특정 자원에 접근 할 수 있습니다.
  * 뮤텍스를 특정 종류의 세마포어 형식으로 부를 수 있습니다.
* **세마포어**
  * 여러 프로세스 또는 스레드가 동시에 접근을 허용 할 수 있는 정수 카운터를 사용합니다.
  * 뮤텍스와 유사하지만 세마포어는 뮤텍스가 될 수 없습니다.
* **조건 변수 (signal)**
  * 이는 주로 뮤텍스와 함께 사용됩니다.&#x20;
  * 스레드는 조건 변수 x를 기다리는 동안 뮤텍스를 해제하고
  * 다른 스레드가 특정 조건을 만족하여 조건 변수x에 signal를 보내면,
  * x를 기다리던 스레드가 깨어나 뮤텍스를 얻고 작업을 수행합니다.
* **스핀락**
  * 반복문을 돌며 계속 기다리는 방식입니다.
  * 뮤텍스와다른점은 CPU 자원을 계속하여 소모하기 때문에 대기 시간이 짧은 경우에 효과적입니다.
* **데드락 방지 기법**
  * **상호배제, 점유와 대기, 비선점, 순환 대기** 4가지 조건 중 하나를 제거하는 방법입니다.

## ⚡ 메모리

### 가상메모리를 왜 사용할까요?

* 실제 물리적인 메모리보다 더 큰 메모리를 사용하는 것처럼 느낄 수 있습니다.
  * 이는 프로그램 실행 시 실제 필요한 메모리만을 할당받아 올리고 나머지는 디스크의 swap area에 저장하여 사용 할 수 있습니다.
* 메모리에 대한 제한된 액세스 권한을 부여하여 메모리를 보호할 수 있습니다.
* 필요한 경우 스와핑과 페이지 아웃을 통해 물리적인 메모리에서 디스크로 쫒아 낼 수 있습니다.
* 가상 메모리는 미리 읽기와 지연된 할당 등의 기술을 통해 성능을 향상 시킬 수 있습니다.
  * 필요한 페이지들을 미리 물리적 메모리로 가져오거나, 페이지를 실제로 필요한 시점에 할당하여 성능을 향상 시킬 수 있습니다.
* 각 프로세스는 독립적으로 실행되지만 메모리를 공유해야 할 때가 있어 이 때 가상메모리를 통해 독립된 가상 주소 공간을 제공하여 프로세스 간에 충돌을 방지하고 보호 할 수 있습니다.

### 내부 단편화와 외부 단편화의 차이점에 대해 설명해주세요

* 내부 단편화는 메모리 내에서 프로세스가 할당받은 공간이 실제로 사용하고 있는 공간보다 커서 발생하는 문제이고,
* 외부 단편화는 프로그램을 할당하며 생기는 작은 메모리들이 더 이상 할당되지 않는 조각들이 발생하는 문제입니다. 이는 주로 동적 할당 할 때 많이 발생합니다.

### 스택과 힙의 차이점

#### 스택

* 주로 스택은 정적할당이 이루어지며 컴파일 타임에 크기가 결정됩니다.
* 지역 변수, 매개변수, 반환 주소 등이 스택에 할당됩니다.
* 스택의 생명 주기는 함수 호출 시 생성되고 함수 종료 시 소멸 됩니다.

#### 힙

* 주로 힙은 동적 할당이 이루어지며 런타임에 크기가 동적으로 결정됩니다.
* 메모리를 동적으로 할당하고 해제해야 하므로 메모리 누수나 다른 메모리 오류를 방지하기 위해 신경을 써야합니다.
* 힙은 스택에 비해 큰 메모리 영역을 제공하며 큰 데이터 구조나 객체 등을 관리 할 수 있습니다.
* 힙의 생명 주기는 처음에 할당 한 후 명시적으로 해제 하지 않으면 프로그램이 종료 될 때 까지 유지됩니다.
