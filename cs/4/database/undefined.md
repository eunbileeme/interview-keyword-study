# 고청천

## SQL

### Delete와 Truncate 차이

DELETE는 where 절을 통해 행단위를 삭제할 수 있으며 삭제 시 트랜잭션 로그에 기록되서 commit 전에 롤백이 가능합니다. 반면 TRUNCATE는 즉시 커밋되어 롤백 할 수 없습니다

### DROP 과 Truncate의 차이

DROP의 경우 테이블을 전체 다 내리는 것을 의미하며 TRUNCATE는 테이블 구조를 제외하고 삭제하는 것을 의미합니다

### 외래키로 다른 테이블에 참조되고 있을 때, DROP, TRUNCATE, DELETE 동작

참조 무결성 조건으로 인해 해당 메서드들은 동작하지 못합니다 명령어가 정상적으로 동작하기 위해서는 외래키를 소유하고 있는 테이블을 먼저 삭제하여야 합니다

### UNDO, Rollback의 차이

UNDO 는 시스템 레벨의 장애가 낫을 때 이전으로 돌아가는 명령어 이며 Rollback 은 쿼리문에 오류가 생겼을 때 이전 상태로 돌아가는 것입니다

REDO 로그를 사용해서 과거 데이터를 최신 데이터 쪽으로 흐르게 하는 것을 롤 포워드라고 한다 반대로 UNDO 로그를 사용해 변경을 취소하는 것을 롤백이라고 한다

데이터가 변경되면 UNDO 정보가 생성되며 생성된 정보는 세그먼트에 저장 UNDO 정보가 보관되는 테이블스페이스를 UNDO 테이블스페이스라고 부른다 이곳에는기여러본개의적 UNDO 세그먼트가으생성로된다 트랜잭션과 UNDO 세그먼트는 1대1 대응

### DISTINCT와 Group by 차이

<figure><img src="../../../.gitbook/assets/image (94).png" alt=""><figcaption><p>DISTINCT 시</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (95).png" alt=""><figcaption><p>GROUP BY 시</p></figcaption></figure>

DISTINCT, GROUP BY는 테이블을 SELECT시 조회 결과를 그룹으로 묶어서 가져오는 역할을 합니다

이 둘의 차이는 Group by는 결과물을 정렬해서 표현하고 DISTINCT 는 결과물을 정렬하지 않는 다는 것 입니다.



아무래도 단순 중복 제거만 이용하는 게 목적이라면 DISTINCT가 성능 상 이점이 있습니다. 앞서 이야기 했던 대로 GROUP BY는 추가적으로 정렬까지 진행하기 때문입니다



## 동시성

### 동시성 이란?

동시성은 동시에 실행 중인 것 처럼 행동하는 것을 의미합니다. 이를 위해 CPU 는 빠른 문맥 교환을 통해 여러 작업이 동시에 실행되는 것 처럼 보일 수 있습니다.

이러한 환경에서는 동시성 이슈를 고려해 주어야 합니다. 동시성 이슈는 여러 작업이 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 것입니다.

이러한 이슈를 방지하기 위해서 애플리케이션 단에서 쓰레드 흐름 제어를 이용하거나 db에서 락을 거는 방법이 있습니

### 데이터를 짧은 간격으로 동시 삽입할 경우 어떻게 막으실건가요?

데이터를 짧은 간격으로 동시 삽입 될 경우, 데이터 베이스 락이나 트랜잭션 격리 수준 변경을 고려 해볼 수 있을 거 같습니다.

비관적 락 같은 데이터 베이스 락을 통해 동시성으로 값이 예상치 못하게 변경되는 것을 예방 할 수 있으며

트랜잭션 격리 수준을 통해 개별 트랜잭션의 고립 수준을 올려 각자의 작업에 침입하는 것을 미연에 방지 할 수 있습니다

### MVCC 란?

MVCC, 즉 다중 버전 동시성 관리는 데이터베이스에서 동시성을 향상시키기 위해 사용되는 기술입니다. 이 기술의 핵심은 데이터의 여러 '스냅샷'을 생성하여, 쓰기 작업이 진행되는 동안에도 읽기 작업이 충돌 없이 이루어질 수 있도록 하는 것입니다.

MySQL에서는 MVCC를 구현하는 데 언두 로그를 활용합니다. 언두 로그는 트랜잭션 전과 후의 데이터 상태를 기록하는데, 이를 통해 데이터베이스는 과거의 데이터 상태를 재구성할 수 있게 됩니다

### 동시성을 해결하는 방법

동시성을 해결하기 위해 데이터 베이스에서는 비관적 락과 낙관적 락을 고려해 볼 수 있을 것이고 애플리케이션 단에서는 세마 포어나 Syncronized 와 같은 쓰레드 흐름제어를 고려해 볼 수 있을 것 같습니다.

이 중 세마 포어의 경우 자원에 접근할 수 있는 쓰레드 수를 제한 하여, 동시성 해결에 도움을 줄 수 있습니다.

제가 진행한 공연 프로젝트에서는 reentrantlock를 통해서 동시성 이유를 해결 했습니다

### DB 데드락 발생조건

데드락이란 서로 다른 트랜잭션 2개가 같은 데이터에 대한 락을 서로 획득하려고 무한정 대기하는 것을 뜻합니다.

데드락의 발생 조건은 상보 배제와 점유 대기 비선점 그리고 순환 대기가 있습니다

상호 배제는 한 시점에 한 트랜잭션만이 특정 리소스(예: 행, 테이블)에 대한 접근 권한을 가질 수 있습니다. 다른 트랜잭션이 동시에 같은 리소스에 접근할 수 없습니다.

점유 대기는 한 트랜잭션이 최소한 하나의 리소스를 점유하고 있으면서 동시에 다른 리소스를 기다리는 상태입니다.

비선점은 트랜잭션이 일단 리소스를 점유하면, 해당 리소스는 그 트랜잭션이 자발적으로 해제하기 전까지 다른 트랜잭션에 의해 선점(강제로 빼앗음)될 수 없습니다.

순환 대기는 두 개 이상의 트랜잭션이 서로의 자원을 순환적으로 기다리는 상태입니다. 이는 대기하는 트랜잭션들 간에 닫힌 체인이 형성됩니다.

우선 데드락이 발생하면 로그 분석등을 통해 문제 원인을 찾고 그에 따라 쿼리를 최적화 시키거나 트랜잭션을 최적화 시킬 것입니다.

또한 제가 주로 사용하는 MySQL 에는 데드락 탐지 스레드가 있습니다. 이를 통해 자체적으로 데드락을 감지하고 가장 작은 양의 작업을 수행한 트랜잭션 부터 하나씩 롤백 시키는 방식으로 데드락을 자동으로 해결해 주고 있습니다

### 비관적 락과 낙관적 락 차이

비관적 락은 동시성 문제가 발생할 것이라 예상하고 락을 걸고 시작하는 방법 입니다. 이를 통해 충돌이 자주 발생하는 환경에서는 롤백횟수를 줄일 수 있어 성능상 이점이 있습니다 다만 락으로 인해 데드락 발생 가능성이 있습니다. 그리고 동시성이 떨어지는 문제도 있습니다

낙관적 락은 자원에 미리 락을 걸지 말고 문제가 발생하면 그떄 처리하자는 방법입니다 이로 인해 동시성은 높아지지만, 잦은 충돌이 발생하면 롤백 처리에 대한 비용이 많이 듭니다

## 공격

### SQL 인젝션이란?

[https://hobbylists.tistory.com/entry/%EB%93%9C%EB%A6%BC%ED%95%B5-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-Simplesqli-SQL-Injection-query-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9A%B0%ED%9A%8C-SQL](https://hobbylists.tistory.com/entry/%EB%93%9C%EB%A6%BC%ED%95%B5-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-Simplesqli-SQL-Injection-query-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9A%B0%ED%9A%8C-SQL)

보안상의 취약점을 이용해 임의의 SQL문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위입니다

사용자 입력이 SQL 쿼리에 직접 포함되어, 악의적인 사용자가 의도한 SQL 코드가 데이터베이스에 전달되고 실행됩니다.

웹 폼을 통해 사용자 이름과 비밀번호를 입력받는 로그인 프로세스에서, 공격자는 특정 SQL 구문을 비밀번호 입력란에 입력할 수 있습니다. 애플리케이션에서 이 입력을 적절히 필터링하거나 이스케이프 처리하지 않는 경우, 공격자는 인증 과정을 우회하거나 다른 SQL 명령을 실행할 수 있습니다.

### SQL 인젝션 방어 방법

<figure><img src="../../../.gitbook/assets/image (96).png" alt=""><figcaption></figcaption></figure>

SQL 인젝션을 방지하기 위한 주요 방법으로는 두 가지 접근법이 있습니다. 첫 번째는 준비된 명령(Prepared Statements)을 사용하는 것이고, 두 번째는 ORM(Object-Relational Mapping) 프레임워크를 활용하는 것입니다.

준비된 명령(Prepared Statements): 이 방법은 SQL 쿼리를 미리 정의하고, 사용자의 입력은 파라미터로만 받는 방식입니다. 준비된 명령은 SQL 구문과 데이터를 분리하므로, 사용자 입력이 SQL 쿼리의 일부로 직접적으로 해석되는 것을 방지합니다. 이는 공격자가 악의적인 코드를 삽입하는 것을 효과적으로 차단합니다.

ORM 프레임워크는 데이터베이스 테이블을 객체로 매핑하여, SQL 쿼리를 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있게 해줍니다. 많은 ORM 프레임워크는 내부적으로 준비된 명령을 사용하고, 사용자 입력을 적절히 이스케이프 처리함으로써 SQL 인젝션을 방지합니다.
