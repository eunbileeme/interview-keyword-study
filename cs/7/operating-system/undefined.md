# 고청천

## 페이징

### 페이징과 세그먼테이션

페이징이란 프로세스의 주소 공간을

일정한 크기의 페이지로 나눠서

메모리의 서로 다른 위치에 프로세스를 적재하는 기법입니다.



세그먼테이션이란

프로세스의 주소 공간을 의미 단위인 세그먼트로 나누어

메모리의 서로 다른 위치에 적재하는 기법 입니다.

일반적으로는 코드, 데이터, 스택 등을 기준으로 세그먼트를 정의 합니다.

### 페이징이 메모리 효율적인 이유

페이징 시스템을 사용하면, 메모리는 고정 크기의 페이지로 나누어집니다. 이로 인해 외부 단편화 문제가 발생하지 않습니다. 외부 단편화는 프로세스가 메모리에 할당되고 해제될 때 발생하는 빈 공간(홀)로 인해 사용 가능한 메모리가 충분함에도 불구하고, 큰 블록의 메모리를 할당할 수 없는 문제를 말합니다. 페이징은 이러한 문제를 해결하여 메모리 사용 효율을 높입니다.

## 페이지 교체 알고리즘

### LRU 알고리즘

LRU는 페이지 교체 알고리즘 입니다.

LRU는 페이지 교체를 할 때

가장 오래전에 참조 되었던 페이지를

메모리에서 쫓아 냅니다.

최근에 참조된 페이지가

가까운 미래에 다시 참조될 가능성이 높다는

시간 지역성이란 성질을 활용한 알고리즘 입니다.

하지만 문제점 있을 수 있습니다.

만약 과거로부터 가장 많이 참조 되었지만

가장 오래전에 참조 되었던 페이지를 내쫓는 경우가 발생할 수 있습니다.

### 페이지 교체 알고리짐

CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않은 상황이(페이지 부재) 발생하면 해당 페이지를 디스크에서 메모리로 읽어와야 합니다.

이때 물리적 메모리의 페이지 프레임 중 빈 공간이 없다면, 현재 적재 되어있는 페이지 중 하나를 디스크로 쫓아내서 빈 공간을 마련해야 합니다.

이러한 작업을 페이지 교체라고 합니다.

대표적으로 위에서 설명한 LRU 그리고 FIFO 가 있습니다

### FIFO 단점

FIFO 페이지 교체 알고리즘은 메모리에 올라온 순서만 고려하고 자주 사용하는 페이지를 고려하지 않기 때문에 성능이 좋지 않을 수 있습니다.

## 동기와 비동기

### 비동기와 병렬

비동기는 작업을 비순차적으로 처리하는 것을 의미합니다

병렬의 경우 멀티 코어 프로세서에서 동시에 실행되는 동일한 작업의 여러 작업에 관한 것

### 핸드폰 알림 비유를 통해 비동기 설명

휴대폰 알림을 설정하고 유튜브 영상을 시청한다 가정하겠습니다. 유튜브 영상을 시청하면서 알람이 언제 울릴지 계속 확인하지 않아도 됩니다. 그러다 알람이 울리게 되면, 사용자는 알람이 울렸다는 것을 알게 되고(콜백) 이를 확인한다음 알람을 끄는 작업을 할 수 있습니다.

## 블로킹 IO 와 논 블로킹 IO

### 논 블로킹 IO 감지법

논블로킹 I/O의 상태는 select, poll, epoll 등의 시스템 호출을 통해 확인할 수 있습니다. 이들 함수는 여러 파일 디스크립터의 상태를 동시에 모니터링 할 수 있으며, 이들 중 하나가 I/O 작업을 수행할 준비가 되면 알려줍니다.

### 논 블로킹 IO 주의점

**복잡한 코드 구조**: 논블로킹 I/O를 사용하면 코드 구조가 복잡해질 수 있습니다. 왜냐하면 각 I/O 호출 후에 반환값을 체크하고, I/O가 완료되지 않았다면 나중에 다시 시도해야 하기 때문입니다. 이렇게 되면 코드가 복잡해지고, 디버깅이 어려워질 수 있습니다.

**리소스 관리**: 논블로킹 I/O를 사용하면, 언제, 어떤 I/O 연산이 완료될지 예측하기 어려울 수 있습니다. 이로 인해 리소스 관리가 어려워질 수 있습니다.

### 비동기와 논 블로킹 차이점

비동기는“작업 완료 여부”를 신경쓰는지에 대한 관점으로 볼 수 있고, 논블로킹은 “내가 직접 제어할 수 없는 대상(IO/멀티스레드)를 상대하는 방법”으로 볼 수 있습니다.

<figure><img src="../../../.gitbook/assets/image (29).png" alt=""><figcaption></figcaption></figure>
